<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Math Drill ‚Äî Basic Facts</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; text-align:center; padding: 2rem; }
    h1 { margin-top: 0; }
    #drill, #done { display:none; }
    #feedback { font-size: 1.25rem; margin: .75rem 0; min-height: 1.5em; }
    input[type="text"], input[type="number"] { font-size: 1.5rem; width: 140px; text-align:center; }
    button { font-size: 1rem; padding: .6rem 1rem; }
    .setup-section { margin: 1rem 0; }
    .grid { display:grid; gap:.5rem; justify-content:center; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); }
    .card { border:1px solid #ddd; border-radius: 10px; padding: .75rem 1rem; text-align:left; }
    ul { list-style: none; padding: 0; margin: 0; }
    label { user-select:none; }

    /* vertical operation display */
    .qbox { display:flex; justify-content:center; }
    pre.vert { text-align:right; line-height: 1.6; font-size: 2rem; margin: .5rem 0 0; }
    .opline { border-top: 3px solid #333; width:100%; margin:.25rem 0 0; }

    /* fireworks overlay */
    #fireworks { position: fixed; inset:0; width:100%; height:100%; pointer-events:none; z-index:5; }

    /* sand overlay (behind UI but above fireworks) */
    #sandCanvas { position:fixed; inset:0; pointer-events:none; z-index:1; }
    #setup, #drill, #done { position:relative; z-index:10; }
    #answer {position: relative;  z-index: 25; /* higher than drawCanvas (which is z-index:20) */
}

    /* screen shake animation for sand explosion */
    @keyframes screenShake {
      0%, 100% { transform: translate(0, 0); }
      10% { transform: translate(-2px, -1px); }
      20% { transform: translate(2px, 1px); }
      30% { transform: translate(-1px, 2px); }
      40% { transform: translate(1px, -2px); }
      50% { transform: translate(-2px, 1px); }
      60% { transform: translate(2px, -1px); }
      70% { transform: translate(-1px, -2px); }
      80% { transform: translate(1px, 2px); }
      90% { transform: translate(-2px, -1px); }
    }

  </style>
</head>
<body>
  <h1>Math Drills: + - / * </h1>

  <!-- SETUP -->
  <div id="setup">
    <div class="setup-section">
      <label>How many questions? <input id="totalQuestions" type="number" value="50" min="1" max="500"></label>
    </div>

    <div class="setup-section card">
      <strong>Choose problem types (any mix):</strong>
      <ul>
        <li><label><input type="checkbox" id="typeAdd" checked> Addition</label></li>
        <li><label><input type="checkbox" id="typeSub" checked> Subtraction</label></li>
        <li><label><input type="checkbox" id="typeMul"> Multiplication</label></li>
        <li><label><input type="checkbox" id="typeDiv"> Division</label></li>
      </ul>
    </div>

    <div class="grid">
      <div class="setup-section card">
        <strong>Settings ‚Äî Addition & Subtraction</strong>
        <div style="margin:.5rem 0 .25rem;">Digit counts (any mix):</div>
        <ul>
          <li><label><input type="checkbox" id="digits1" checked> 1-digit</label></li>
          <li><label><input type="checkbox" id="digits2" checked> 2-digit</label></li>
          <li><label><input type="checkbox" id="digits3"> 3-digit</label></li>
          <li><label><input type="checkbox" id="digits4"> 4-digit</label></li>
        </ul>
        <div style="margin:.5rem 0 .25rem;">Addends for + and ‚àí:</div>
        <ul>
          <li><label><input type="checkbox" id="addends2" checked> 2 numbers</label></li>
          <li><label><input type="checkbox" id="addends3"> 3 numbers</label></li>
        </ul>
        <label style="display:block; margin-top:.5rem;"><input type="checkbox" id="noCarryBorrow"> No carry / borrow (construct problems so regrouping is never needed)</label>
      </div>

      <div class="setup-section card">
        <strong>Settings ‚Äî Multiplication & Division</strong>
        <ul>
          <li><label><input type="checkbox" id="allow0"> Include 0</label></li>
          <li><label><input type="checkbox" id="allow11"> Include 11s</label></li>
          <li><label><input type="checkbox" id="allow12"> Include 12s</label></li>
        </ul>
        <div style="font-size:.9rem; color:#555; margin-top:.25rem;">
          Multiplication defaults to 1‚Äì10 (extend with 0 / 11 / 12 options).<br>
          Division always whole-answer. Dividends ‚â§ 100 (‚â§ 144 if 12s enabled).
        </div>
      </div>

      <div class="setup-section card">
        <strong>Effects</strong>
        <ul>
          <li><label><input type="checkbox" id="fxFireworks"> Fireworks</label></li>
          <li><label><input type="checkbox" id="fxConfetti"> Confetti</label></li>
          <li><label><input type="checkbox" id="fxExplosion"> Explosion</label></li>
          <li><label><input type="checkbox" id="fxCarCrash"> Car crash</label></li>
          <li><label><input type="checkbox" id="fxMeteors"> Meteor shower</label></li>
          <li><label><input type="checkbox" id="fxDinoStomp"> Dino stomp</label></li>
          <li><label><input type="checkbox" id="fxLightning"> Lightning bolts</label></li>
          <li><label><input type="checkbox" id="fxRocketLaunch"> Rocket launch</label></li>
          <li><label><input type="checkbox" id="fxRainbowSand" checked> Rainbow sand</label></li>
        </ul>
      </div>
    </div>

    <button id="startBtn">Start</button>
  </div>

  <!-- DRILL -->
  <div id="drill">
    <h2 id="counter"></h2>
    <div id="question" class="qbox"></div>
    <div id="hint" style="font-style:italic; margin-bottom:.5rem;"></div>
    <input id="answer" type="text" inputmode="numeric" pattern="[0-9]*" autofocus onkeydown="if(event.key==='Enter'){checkAnswer()}" />
    <button id="wipeBtn" type="button" style="
      position: fixed;
      bottom: 1rem;
      right: 1rem;
      z-index: 30;
      font-size: 1rem;
      padding: 0.4rem 0.8rem;
      background: #007BFF;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      display: none;
    ">Wipe Screen</button>
    <div id="feedback"></div>
  </div>

  <!-- DONE -->
  <div id="done">
    <h2>‚úÖ All done!</h2>
    <p id="summary"></p>
    <div id="troubleSection" style="display:none;">
      <h3>Facts to practice more:</h3>
      <ul id="troubleList"></ul>
    </div>
  </div>

  <canvas id="fireworks"></canvas>
  <canvas id="sandCanvas"></canvas>

  <script>
    // -------------------- GLOBAL STATE --------------------
    let total = 20, current = 0, startTime = 0, locked = false;
    const mistakes = {};

    // Settings
    let activeTypes = [];
    let allow0=false, allow11=false, allow12=false, noCarryBorrow=false;
    let digitChoices = [];   // subset of [1,2,3,4]
    let addendCounts = [];   // subset of [2,3]
    let activeFX = [];

    // -------------------- UI WIRING --------------------
    document.addEventListener('DOMContentLoaded', () => {
      document.getElementById('startBtn').addEventListener('click', startDrill);
    });

    function startDrill() {
      startTime = Date.now();
      total = clampInt(document.getElementById('totalQuestions').value, 1, 500, 50);

      // effects
      activeFX = [];
      pushIfChecked('fxFireworks', 'fireworks');
      pushIfChecked('fxConfetti', 'confetti');
      pushIfChecked('fxExplosion', 'explosion');
      pushIfChecked('fxCarCrash', 'carCrash');
      pushIfChecked('fxMeteors', 'meteorShower');
      pushIfChecked('fxDinoStomp', 'dinoStomp');
      pushIfChecked('fxLightning', 'lightningStrike');
      pushIfChecked('fxRocketLaunch', 'rocketLaunchExplosion');
      pushIfChecked('fxRainbowSand', 'rainbowSand');

      // types
      activeTypes = [];
      if (document.getElementById('typeAdd').checked) activeTypes.push('add');
      if (document.getElementById('typeSub').checked) activeTypes.push('sub');
      if (document.getElementById('typeMul').checked) activeTypes.push('mul');
      if (document.getElementById('typeDiv').checked) activeTypes.push('div');
      if (activeTypes.length === 0) {
        alert('Select at least one problem type.');
        return;
      }

      // add/sub digit choices
      digitChoices = [];
      collectCheckedDigits();
      addendCounts = [];
      collectCheckedAddends();
      if ((isTypeActive('add') || isTypeActive('sub')) && digitChoices.length === 0) {
        alert('Select at least one digit count for addition/subtraction.');
        return;
      }
      if ((isTypeActive('add') || isTypeActive('sub')) && addendCounts.length === 0) {
        alert('Select 2 or 3 numbers for addition/subtraction.');
        return;
      }

      // toggles
      allow0 = document.getElementById('allow0').checked;
      allow11 = document.getElementById('allow11').checked;
      allow12 = document.getElementById('allow12').checked;
      noCarryBorrow = document.getElementById('noCarryBorrow').checked;

      // reset counters
      current = 0;
      locked = false;
      for (const k of Object.keys(mistakes)) delete mistakes[k];

      // show drill
      show('drill');
      hide('setup');
      hide('done');

      // üñäÔ∏è Enable drawing and position overlay for the first question
      drawCanvas.style.pointerEvents = 'auto';
      positionDrawCanvasOverQuestion();
      showWipeButton(true);

      nextQuestion();
    }

    function show(id){ document.getElementById(id).style.display='block'; }
    function hide(id){ document.getElementById(id).style.display='none'; }
    function pushIfChecked(id, val){ if(document.getElementById(id).checked) activeFX.push(val); }
    function isTypeActive(t){ return activeTypes.includes(t); }
    function clampInt(v,min,max,def){ v=parseInt(v,10); if(Number.isNaN(v)) return def; return Math.max(min, Math.min(max,v)); }

    function collectCheckedDigits(){
      if(document.getElementById('digits1').checked) digitChoices.push(1);
      if(document.getElementById('digits2').checked) digitChoices.push(2);
      if(document.getElementById('digits3').checked) digitChoices.push(3);
      if(document.getElementById('digits4').checked) digitChoices.push(4);
    }
    function collectCheckedAddends(){
      if(document.getElementById('addends2').checked) addendCounts.push(2);
      if(document.getElementById('addends3').checked) addendCounts.push(3);
    }

    // -------------------- GENERATORS --------------------

    let currentQ = null;   // { html, text }
    let currentA = null;   // integer

    function nextQuestion() {
      current++;
      if (current > total) return endDrill();

      const type = randChoice(activeTypes);
      let problem;
      if (type === 'add') problem = genAddition();
      else if (type === 'sub') problem = genSubtraction();
      else if (type === 'mul') problem = genMultiplication();
      else problem = genDivision();

      currentQ = problem.q;
      currentA = problem.a;

      const counterEl = document.getElementById('counter');
      const qEl = document.getElementById('question');
      const hintEl = document.getElementById('hint');
      const ans = document.getElementById('answer');
      const feedbackEl = document.getElementById('feedback');

      counterEl.textContent = `Question ${current} of ${total}`;
      qEl.innerHTML = problem.q.html; // render the math problem
      hintEl.textContent = problem.hint || '';
      ans.value = '';
      feedbackEl.textContent = '';
      locked = false;

      // ‚úÖ Wait two animation frames so the DOM actually paints before we measure
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          positionDrawCanvasOverQuestion();
          drawCanvas.style.pointerEvents = 'auto';
        });
      });

      setTimeout(() => ans.focus(), 100);
    }


    // ---- Addition ----
    function genAddition(){
      const digits = randChoice(digitChoices);
      const addends = randChoice(addendCounts);

      let nums;
      if(noCarryBorrow){
        nums = buildNoCarryAddition(addends, digits);
      } else {
        nums = buildRandomNDigitList(addends, digits, true); // non-negative, allow carries
      }
      const answer = nums.reduce((s,n)=>s+n,0);
      return { q: makeVerticalQuestion(nums, '+'), a: answer, hint: '' };
    }

    // Build addition operands so each column sum < 10
    function buildNoCarryAddition(k, d){
      // choose per-column digits that sum < 10, then compose numbers
      const cols = [];
      for(let i=0;i<d;i++){
        let remaining = Math.floor(Math.random()*10); // target sum for this column (0..9)
        // Ensure remaining < 10; bias upward for variety
        if(remaining>8) remaining = 8;
        const col = new Array(k).fill(0);
        for(let j=0;j<k;j++){
          const pick = (j===k-1) ? remaining : Math.floor(Math.random()*(remaining+1));
          col[j] = pick; remaining -= pick;
        }
        // randomize order within column
        shuffle(col); cols.push(col);
      }
      // highest column must not lead with 0 for the first number
      if(cols[d-1][0]===0){
        // find an index with >0 and swap into first slot
        const idx = cols[d-1].findIndex(v=>v>0);
        if(idx>0){ const tmp=cols[d-1][0]; cols[d-1][0]=cols[d-1][idx]; cols[d-1][idx]=tmp; }
        else { // all zeros in top column ‚Üí force a 1 into first addend's highest column
          cols[d-1][0]=1;
        }
      }
      // compose numbers from columns
      const nums = new Array(k).fill(0);
      for(let c=0;c<d;c++){
        for(let r=0;r<k;r++) nums[r] += cols[c][r]*Math.pow(10,c);
      }
      return nums;
    }

    // ---- Subtraction ----
    function genSubtraction(){
      const digits = randChoice(digitChoices);
      const terms = randChoice(addendCounts); // 2 or 3 numbers ‚Üí A - B ( - C )

      let minuend, subs;
      if(noCarryBorrow){
        ({minuend, subs} = buildNoBorrowSubtraction(terms, digits));
      } else {
        // Build random B and C then choose A large enough
        subs = buildRandomNDigitList(terms-1, digits, true);
        const subSum = subs.reduce((s,n)=>s+n,0);
        const low = Math.max(subSum, Math.pow(10,digits-1));
        const high = Math.pow(10,digits)-1;
        minuend = randInt(low, high);
      }
      const nums = [minuend, ...subs];
      const answer = nums.slice(1).reduce((a,n)=>a-n, minuend);
      return { q: makeVerticalQuestion(nums, '‚àí'), a: answer, hint: '' };
    }

    // Build subtraction A - B (- C) with no borrow: per column, A_digit >= sum(B_digit, C_digit)
    function buildNoBorrowSubtraction(k, d){
      const subCount = k-1; // 1 or 2
      const cols = [];
      // choose subtrahend digits per column, then choose minuend digit >= their sum
      for(let i=0;i<d;i++){
        const subDigits = new Array(subCount).fill(0);
        let sum = 0;
        for(let j=0;j<subCount;j++){
          const pick = randInt(0, 9 - sum); // keep sum <=9
          subDigits[j] = pick; sum += pick;
        }
        const aDigit = randInt(sum, 9);
        cols.push([aDigit, ...subDigits]);
      }
      // highest column must not lead with 0 for A
      if(cols[d-1][0]===0) cols[d-1][0]=randInt(1,9);
      // compose numbers
      const numList = new Array(k).fill(0);
      for(let c=0;c<d;c++){
        for(let r=0;r<k;r++) numList[r] += cols[c][r]*Math.pow(10,c);
      }
      const minuend = numList[0];
      const subs = numList.slice(1);
      return { minuend, subs };
    }

    // ---- Multiplication ----
    function genMultiplication(){
      const a = pickTimesTableFactor(); // 0/1..12 depending on toggles
      const b = pickTimesTableFactor();
      // Default should feel like 0‚Äì10 unless toggles expand it
      // If neither 11 nor 12 allowed, cap to 0..10/1..10
      const limited = (allow11||allow12) ? null : 10;
      const aa = constrainFactor(a, limited);
      const bb = constrainFactor(b, limited);
      const x = aa, y = bb;
      return { q: { html: `<div style="font-size:2rem;">${x} √ó ${y} = ?</div>`, text: `${x} √ó ${y} = ?` }, a: x*y, hint: '' };
    }

    // ---- Division (whole answers only) ----
    function genDivision(){
      // Choose divisor from allowed tables (1..12, maybe 0)
      let divisor = pickTimesTableFactor(true);
      if(divisor===0){ // if 0 allowed, force quotient 0 and dividend 0
        return { q: { html: `<div style="font-size:2rem;">0 √∑ 0 = ?</div>`, text: `0 √∑ 0 = ?` }, a: NaN, hint: 'Undefined ‚Äî but this case should be avoided. Toggle off 0 if this appears.' };
      }

      // Choose quotient range 0..10 (extend to 12 if toggled). 0 permitted only if allow0.
      let qMin = allow0 ? 0 : 1;
      let qMax = allow12 ? 12 : 10;
      if(!allow11 && qMax>=11) qMax = 10;
      if(!allow12 && qMax>=12) qMax = Math.min(qMax, 11);

      // Loop until dividend constraint is met (‚â§100, or ‚â§144 if 12s enabled)
      let quotient, dividend, cap = allow12 ? 144 : 100, tries=0;
      do {
        quotient = randInt(qMin, qMax);
        dividend = divisor * quotient;
        tries++;
        if(tries>200){ // fallback safety
          quotient = Math.min(qMax, Math.floor(cap / Math.max(1,divisor)));
          dividend = divisor * quotient; break;
        }
      } while(dividend > cap);

      // Ensure simple whole-number division
      return { q: { html: `<div style="font-size:2rem;">${dividend} √∑ ${divisor} = ?</div>`, text: `${dividend} √∑ ${divisor} = ?` }, a: quotient, hint: '' };
    }

    // Helpers for tables
    function pickTimesTableFactor(forDivisor=false){
      // Base range 1..10; include 0 if allowed; optionally include 11/12
      let options = [];
      if(allow0) options.push(0);
      for(let n=1;n<=10;n++) options.push(n);
      if(allow11) options.push(11);
      if(allow12) options.push(12);
      // For divisors, never pick 0 unless explicitly allowed; handled above.
      if(forDivisor && !allow0) options = options.filter(n=>n!==0);
      return randChoice(options);
    }
    function constrainFactor(val, cap10){
      if(cap10==null) return val;
      if(val===0) return allow0 ? 0 : randInt(1,10);
      return Math.min(val, cap10);
    }

    // ---- Utilities ----
    function randInt(min, max){ return Math.floor(Math.random()*(max-min+1))+min; }
    function randChoice(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
    function shuffle(arr){ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; } }

    function buildRandomNDigitList(k, d, forbidLeadingZero){
      const low = Math.pow(10, d-1);
      const high = Math.pow(10, d)-1;
      const nums = [];
      for(let i=0;i<k;i++){
        if(d===1){ nums.push(randInt(0,9)); }
        else {
          let n = randInt(low, high);
          if(!forbidLeadingZero){ n = randInt(0, high); }
          nums.push(n);
        }
      }
      // ensure top operand not 0 for multi-digit presentation in vertical format
      if(nums[0]===0 && d>1) nums[0]=randInt(low, high);
      return nums;
    }

    function makeVerticalQuestion(numbers, op){
      // Render numbers right-aligned with operator placed on the LAST line (standard layout)
      const s = numbers.map(n=>String(n));
      const width = Math.max(...s.map(x=>x.length));
      const lines = s.map((x,i)=>{
        const mark = (i===s.length-1) ? (op==='+'?'+': op==='‚àí'?'‚àí':'') : ' ';
        return `${mark} ${x.padStart(width,' ')}`;
      });
      const html = `<div><pre class="vert">${lines.join('\n')}\n${' '.repeat(0)}${'\u2500'.repeat(width + 3)}</pre></div>`;
      const text = lines.join('\n');
      return { html, text };
    }

    // -------------------- CHECK ANSWER --------------------
    function checkAnswer(){
      if(locked) return;
      const raw = document.getElementById('answer').value.trim();
      if(raw==='') return;
      // strictly whole numbers
      if(!/^\d+$/.test(raw)) { wrong(); return; }
      const val = parseInt(raw,10);
      if(val === currentA){ correct(); } else { wrong(); }
    }

    function correct(){
      const fb = document.getElementById('feedback');
      fb.textContent = '‚úÖ Correct!';
      clearDrawCanvas();
      triggerEffects();
      locked = true;
      setTimeout(nextQuestion, 900);
    }
    function wrong(){
      const fb = document.getElementById('feedback');
      fb.textContent = '‚ùå Try again';
      // use the plain text for the question as a key
      const key = currentQ.text || 'q';
      mistakes[key] = (mistakes[key]||0)+1;
    }

    // -------------------- END / SUMMARY --------------------
    function endDrill() {
      hide('drill');
      show('done');

      // üßº Turn off drawing and hide wipe button
      drawCanvas.style.pointerEvents = 'none';
      clearDrawCanvas();
      showWipeButton(false);

      // üéÜ Explode rainbow sand piles
      explodeSandPiles();

      // üïí Time & summary
      const elapsedMin = ((Date.now() - startTime) / 60000).toFixed(1);
      document.getElementById('summary').textContent =
        `You answered ${total} questions in ${elapsedMin} minutes. Great job!`;

      // üéÜ Victory fireworks
      bigFireworksShow();

      // üß† Missed facts list
      const entries = Object.entries(mistakes).sort((a, b) => b[1] - a[1]);
      const list = document.getElementById('troubleList');
      list.innerHTML = '';

      if (entries.length > 0) {
        document.getElementById('troubleSection').style.display = 'block';
        for (const [fact, count] of entries) {
          const li = document.createElement('li');
          li.textContent = `${fact} (missed ${count} time${count > 1 ? 's' : ''})`;
          list.appendChild(li);
        }
      } else {
        document.getElementById('troubleSection').style.display = 'none';
      }
    }


    // -------------------- EFFECTS (reused) --------------------
    function triggerEffects(){
      activeFX.forEach(fx => {
        switch (fx) {
          case 'fireworks': smallFirework(); break;
          case 'confetti':  launchConfetti(); break;
          case 'explosion': spawnExplosion(); break;
          case 'carCrash':  carCrash(); break;
          case 'meteorShower':  meteorShower(); break;
          case 'dinoStomp':  dinoStomp(); break;
          case 'lightningStrike':  lightningStrike(); break;
          case 'rocketLaunchExplosion':  rocketLaunchExplosion(); break;
          case 'rainbowSand': sprinkleSand(); break;
        }
      });
    }

    // ---------- Fireworks base ----------
    const canvas = document.getElementById("fireworks");
    const ctx = canvas.getContext("2d");
    let particles = [], fireworkActive = false;
    function resizeCanvas(){ canvas.width=window.innerWidth; canvas.height=window.innerHeight; }
    window.addEventListener("resize", resizeCanvas); resizeCanvas();
    function spawnFirework(x,y,color,count=30,spread=2*Math.PI){
      for(let i=0;i<count;i++){ const angle=(spread/count)*i; const speed=Math.random()*4+2;
        particles.push({x,y,vx:Math.cos(angle)*speed, vy:Math.sin(angle)*speed, life:80, color}); }
    }
    function updateFireworks(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      particles.forEach(p=>{ p.x+=p.vx; p.y+=p.vy; p.vy+=0.05; p.life--; ctx.globalAlpha=Math.max(p.life/80,0); ctx.fillStyle=p.color; ctx.beginPath(); ctx.arc(p.x,p.y,3,0,Math.PI*2); ctx.fill(); });
      particles = particles.filter(p=>p.life>0);
      if(particles.length>0) requestAnimationFrame(updateFireworks); else fireworkActive=false;
    }
    function smallFirework(){ if(fireworkActive) return; fireworkActive=true;
      const x=window.innerWidth/2+(Math.random()-0.5)*300; const y=window.innerHeight/2+(Math.random()-0.5)*100;
      const colors=["#ff4242","#ffd042","#42ffb3","#4287ff"]; spawnFirework(x,y,randChoice(colors)); updateFireworks(); }
    function bigFireworksShow(){ const colors=["#ff4242","#ffd042","#42ffb3","#4287ff"];
      for(let i=0;i<5;i++){ setTimeout(()=>{ spawnFirework(Math.random()*window.innerWidth, Math.random()*window.innerHeight/2, randChoice(colors), 50); if(!fireworkActive){ fireworkActive=true; updateFireworks(); } }, i*600); } }

    // ---------- Confetti ----------
    function launchConfetti(){
      const totalPieces = 100;
      for(let i=0;i<totalPieces;i++){
        const conf = document.createElement('div');
        conf.style.position='fixed'; conf.style.left=Math.random()*100+'%'; conf.style.top='-20px';
        conf.style.width=(5+Math.random()*5)+'px'; conf.style.height=(5+Math.random()*5)+'px';
        conf.style.backgroundColor = `hsl(${Math.random()*360},100%,50%)`;
        conf.style.zIndex=9999; conf.style.borderRadius = Math.random()<0.3 ? '50%' : '0';
        document.body.appendChild(conf);
        const fallDuration = 2000 + Math.random()*2000; const startDelay = Math.random()*1000; const driftX=(Math.random()-0.5)*400; const spin=Math.random()*720;
        conf.animate([{transform:'translate(0,0) rotate(0deg)',opacity:1},{transform:`translate(${driftX}px, ${window.innerHeight+50}px) rotate(${spin}deg)`,opacity:0}],{duration:fallDuration, delay:startDelay, easing:'ease-in'});
        setTimeout(()=>conf.remove(), fallDuration+startDelay+200);
      }
    }

    // ---------- Explosion ----------
    function spawnExplosion(){
      const centerX=window.innerWidth/2, centerY=window.innerHeight/2;
      const boomColor=['#ff8000','#ffaa00','#ff0000'][Math.floor(Math.random()*3)];
      for(let i=0;i<80;i++){
        const part=document.createElement('div');
        part.style.position='fixed'; part.style.left=centerX+'px'; part.style.top=centerY+'px';
        part.style.width='6px'; part.style.height='6px'; part.style.borderRadius='50%';
        part.style.backgroundColor=boomColor; part.style.zIndex=9999; document.body.appendChild(part);
        const angle=Math.random()*2*Math.PI; const dist=150+Math.random()*150; const x=dist*Math.cos(angle); const y=dist*Math.sin(angle);
        part.animate([{transform:'translate(0,0)',opacity:1},{transform:`translate(${x}px,${y}px)`,opacity:0}],{duration:800});
        setTimeout(()=>part.remove(),800);
      }
      const boom=new AudioContext(); const o=boom.createOscillator(); const g=boom.createGain(); o.connect(g); g.connect(boom.destination); o.type='square'; o.frequency.setValueAtTime(80,boom.currentTime); g.gain.exponentialRampToValueAtTime(0.0001, boom.currentTime+0.4); o.start(); o.stop(boom.currentTime+0.4);
    }

    // ---------- Car crash ----------
    function carCrash(){
      const left=document.createElement('div'), right=document.createElement('div');
      [left,right].forEach(car=>{ car.style.position='fixed'; car.style.top='50%'; car.style.width='60px'; car.style.height='30px'; car.style.backgroundColor='gray'; car.style.border='2px solid black'; car.style.borderRadius='6px'; car.style.zIndex=9999; document.body.appendChild(car); });
      left.style.left='-70px'; right.style.right='-70px';
      left.animate([{transform:'translateX(0)'},{transform:`translateX(${window.innerWidth/2+30}px)`}],{duration:900});
      right.animate([{transform:'translateX(0)'},{transform:`translateX(-${window.innerWidth/2+30}px)`}],{duration:900});
      setTimeout(()=>{ spawnExplosion(); left.remove(); right.remove(); },900);
    }

    // ---------- Meteor Shower ----------
    function meteorShower(){
      const totalMeteors=20;
      for(let i=0;i<totalMeteors;i++){
        const meteor=document.createElement('div');
        meteor.style.position='fixed'; meteor.style.width='3px'; meteor.style.height='60px';
        meteor.style.background='linear-gradient(to bottom, white, rgba(255,255,255,0))';
        meteor.style.borderRadius='50%'; meteor.style.top=Math.random()*window.innerHeight*0.5+'px';
        meteor.style.left=Math.random()*window.innerWidth+'px'; meteor.style.opacity=0; meteor.style.zIndex=9999; meteor.style.transform='rotate(45deg)';
        document.body.appendChild(meteor);
        const startDelay=Math.random()*1000; const distance=300+Math.random()*200;
        meteor.animate([{transform:'translate(0,0) rotate(45deg)',opacity:0},{transform:`translate(-${distance}px, ${distance}px) rotate(45deg)`,opacity:1},{transform:`translate(-${distance*1.3}px, ${distance*1.3}px) rotate(45deg)`,opacity:0}],{duration:1000+Math.random()*1000, delay:startDelay, easing:'ease-out'});
        setTimeout(()=>meteor.remove(), 2200+startDelay);
      }
    }

    // ---------- Dino Stomp ----------
    function dinoStomp(){
      const footColors=["#4caf50", "#388e3c"]; const stompCount=2; const stompDelay=800;
      for(let i=0;i<stompCount;i++){
        setTimeout(()=>{
          const foot=document.createElement('div');
          foot.style.position='fixed'; foot.style.width='160px'; foot.style.height='200px'; foot.style.borderRadius='40% 40% 0 0';
          foot.style.backgroundColor=footColors[i%2]; foot.style.border='4px solid #2e7d32'; foot.style.zIndex=9999; foot.style.left = i===0 ? '20%' : '60%'; foot.style.top='-220px'; foot.style.transform='rotate(' + (i===0?-10:10) + 'deg)'; document.body.appendChild(foot);
          foot.animate([{ transform: foot.style.transform + ' translateY(0)', opacity:1 },{ transform: foot.style.transform + ' translateY(450px)', opacity:1, offset:.8 },{ transform: foot.style.transform + ' translateY(440px)', opacity:1 }], { duration:600, easing:'ease-in' });
          setTimeout(()=>{ const dust=document.createElement('div'); dust.style.position='fixed'; dust.style.left=(i===0?'27%':'67%'); dust.style.top='75%'; dust.style.width='20px'; dust.style.height='20px'; dust.style.borderRadius='50%'; dust.style.background='radial-gradient(rgba(200,200,200,0.8), rgba(200,200,200,0))'; dust.style.zIndex=9998; document.body.appendChild(dust); dust.animate([{transform:'scale(1)',opacity:.8},{transform:'scale(8)',opacity:0}],{duration:1000, easing:'ease-out'}); setTimeout(()=>dust.remove(),1000); }, 500);
          document.body.animate([{transform:'translate(0,0)'},{transform:'translate(5px,-3px)'},{transform:'translate(-5px,4px)'},{transform:'translate(0,0)'}],{duration:300});
          setTimeout(()=>foot.remove(),900);
        }, i*stompDelay);
      }
      const ctx=new AudioContext(); const osc=ctx.createOscillator(); const gain=ctx.createGain(); osc.type='sine'; osc.frequency.setValueAtTime(60, ctx.currentTime); gain.gain.setValueAtTime(0.5, ctx.currentTime); gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime+0.5); osc.connect(gain); gain.connect(ctx.destination); osc.start(); osc.stop(ctx.currentTime+0.5);
    }

    // ---------- Rainbow Sand ----------
    const sandCanvas = document.getElementById("sandCanvas");
    const scx = sandCanvas.getContext("2d", { willReadFrequently: true });
    let SAND_CELL=2, GW=0, GH=0, sand=[], sandAnimating=false, currentHue=0;
    function hexToRGBA32(h){ const n=parseInt(h.slice(1),16); const r=(n>>16)&255, g=(n>>8)&255, b=n&255; return (255<<24)|(r<<16)|(g<<8)|b; }
    function hslToRGBA32(h,s,l){ s/=100; l/=100; const k=n=>(n + h/30)%12; const a=s*Math.min(l,1-l); const f=n=>l - a*Math.max(-1, Math.min(k(n)-3, Math.min(9-k(n),1))); const r=Math.round(255*f(0)); const g=Math.round(255*f(8)); const b=Math.round(255*f(4)); return (255<<24)|(r<<16)|(g<<8)|b; }
    function resizeSand(){ sandCanvas.width=window.innerWidth; sandCanvas.height=window.innerHeight; GW=Math.floor(sandCanvas.width/SAND_CELL); GH=Math.floor(sandCanvas.height/SAND_CELL); sand=new Array(GW*GH).fill(-1); scx.imageSmoothingEnabled=false; }
    window.addEventListener('resize', resizeSand); resizeSand();
    function renderSand(){ 
      const img=scx.createImageData(GW,GH); 
      const buf=new Uint32Array(img.data.buffer); 
      for(let i=0;i<buf.length;i++){ buf[i]= sand[i]===-1 ? 0x00000000 : sand[i]; } 
      
      // Add explosion particles
      if(explosionActive && explosionParticles.length > 0){
        explosionParticles.forEach(particle => {
          const x = Math.floor(particle.x);
          const y = Math.floor(particle.y);
          if(x >= 0 && x < GW && y >= 0 && y < GH){
            const index = y * GW + x;
            buf[index] = particle.color;
          }
        });
      }
      
      const tmp=document.createElement('canvas'); 
      tmp.width=GW; 
      tmp.height=GH; 
      const tctx=tmp.getContext('2d'); 
      tctx.putImageData(img,0,0); 
      scx.imageSmoothingEnabled=false; 
      scx.clearRect(0,0,sandCanvas.width,sandCanvas.height); 
      scx.drawImage(tmp,0,0,sandCanvas.width,sandCanvas.height); 
    }
    function stepSand(speed=2){ for(let s=0;s<speed;s++){ for(let y=GH-2;y>=0;y--){ let rowStart=y*GW; let has=false; for(let x=0;x<GW;x++){ if(sand[rowStart+x]!==-1){ has=true; break; } } if(!has) continue; for(let x=0;x<GW;x++){ const i=y*GW+x; const c=sand[i]; if(c===-1) continue; const below=i+GW; if(below>=sand.length) continue; if(sand[below]===-1){ sand[below]=c; sand[i]=-1; } else { const left=below-1, right=below+1; const lf = x>0 && sand[left]===-1; const rf = x< GW-1 && sand[right]===-1; if(lf && rf){ if(Math.random()<0.5) sand[left]=c; else sand[right]=c; sand[i]=-1; } else if(lf){ sand[left]=c; sand[i]=-1; } else if(rf){ sand[right]=c; sand[i]=-1; } } } } } }
    function loopSand(){ 
      // Update explosion particles
      if(explosionActive && explosionParticles.length > 0){
        explosionParticles = explosionParticles.filter(particle => {
          particle.x += particle.vx;
          particle.y += particle.vy;
          particle.vy += particle.gravity; // Apply gravity
          particle.life--;
          
          // Check if particle has settled (hit bottom or existing sand)
          const x = Math.floor(particle.x);
          const y = Math.floor(particle.y);
          
          // Check if particle hit bottom of screen
          const hitBottom = particle.y >= GH - 5 && particle.vy > 0;
          
          // Check if particle hit existing sand (settled into a pile)
          const hitSand = x >= 0 && x < GW && y >= 0 && y < GH && 
                         y + 1 < GH && sand[(y + 1) * GW + x] !== -1 && particle.vy > 0;
          
          if(hitBottom || hitSand) {
            // Particle has settled, convert back to sand with some horizontal spread
            if(x >= 0 && x < GW && y >= 0 && y < GH) {
              sand[y * GW + x] = particle.color;
            }
            return false; // Remove from explosion particles
          }
          
          // Fade out over time (but not if settling)
          if(particle.life < particle.maxLife * 0.3) {
            const alpha = particle.life / (particle.maxLife * 0.3);
            const color = particle.color;
            const r = (color >> 16) & 255;
            const g = (color >> 8) & 255;
            const b = color & 255;
            particle.color = (Math.floor(255 * alpha) << 24) | (r << 16) | (g << 8) | b;
          }
          
          return particle.life > 0;
        });
        
        // End explosion when all particles are gone
        if(explosionParticles.length === 0){
          explosionActive = false;
        }
        
        // Apply normal sand physics to settled particles during explosion
        stepSand(8); 
        renderSand(); 
        stepSand(8); 
        renderSand();
      } else {
        // Normal sand physics when no explosion
        stepSand(8); 
        renderSand(); 
        stepSand(8); 
        renderSand(); 
      }
      
      if(sandAnimating) requestAnimationFrame(loopSand); 
    }
    function sprinkleSand(count=2000){ if(!sandAnimating){ sandAnimating=true; requestAnimationFrame(loopSand); } const centerX=Math.floor(GW*(0.25+Math.random()*0.5)); const topBand=Math.floor(GH*0.1); currentHue=(currentHue+10)%360; const color=hslToRGBA32(currentHue,80,55); for(let i=0;i<count;i++){ const spread=Math.floor(Math.random()*80)-40; const x=Math.max(0, Math.min(GW-1, centerX+spread)); const y=Math.floor(Math.random()*topBand); sand[y*GW+x]=color; } }

    // ---------- Sand Explosion Effect ----------
    let explosionParticles = [];
    let explosionActive = false;
    
    function findSandPileCenters(sandParticles) {
      if(sandParticles.length === 0) return [];
      
      // Group particles by proximity to find pile centers
      const centers = [];
      const processed = new Set();
      
      sandParticles.forEach(particle => {
        if(processed.has(particle.index)) return;
        
        // Find all particles within 20 pixels of this one
        const nearby = sandParticles.filter(p => {
          const distance = Math.sqrt(
            Math.pow(p.x - particle.x, 2) + 
            Math.pow(p.y - particle.y, 2)
          );
          return distance < 20;
        });
        
        // If we have a cluster of at least 5 particles, it's a pile
        if(nearby.length >= 5) {
          // Calculate center of this pile
          const avgX = nearby.reduce((sum, p) => sum + p.x, 0) / nearby.length;
          const avgY = nearby.reduce((sum, p) => sum + p.y, 0) / nearby.length;
          
          centers.push({
            x: Math.floor(avgX),
            y: Math.floor(avgY),
            size: nearby.length
          });
          
          // Mark all nearby particles as processed
          nearby.forEach(p => processed.add(p.index));
        }
      });
      
      // If no clusters found, create centers from individual particles
      if(centers.length === 0) {
        // Group particles by Y coordinate (bottom of screen)
        const bottomParticles = sandParticles.filter(p => p.y > GH * 0.7);
        if(bottomParticles.length > 0) {
          // Create centers every 50 pixels along the bottom
          const xPositions = [];
          for(let x = 50; x < GW - 50; x += 50) {
            xPositions.push(x);
          }
          
          xPositions.forEach(x => {
            const nearby = bottomParticles.filter(p => Math.abs(p.x - x) < 30);
            if(nearby.length > 0) {
              centers.push({
                x: x,
                y: Math.floor(nearby.reduce((sum, p) => sum + p.y, 0) / nearby.length),
                size: nearby.length
              });
            }
          });
        }
      }
      
      return centers;
    }
    
    function explodeSandPiles(){
      // Find all existing sand particles and make them explode outward
      const existingSand = [];
      
      // Collect all existing sand particles
      for(let y = 0; y < GH; y++){
        for(let x = 0; x < GW; x++){
          const index = y * GW + x;
          if(sand[index] !== -1){
            existingSand.push({
              x: x,
              y: y,
              color: sand[index],
              index: index
            });
          }
        }
      }

      if(existingSand.length === 0) return; // No sand to explode

      // Find sand pile centers (clusters of sand)
      const pileCenters = findSandPileCenters(existingSand);
      console.log(`Found ${pileCenters.length} sand pile centers`);

      // Clear existing sand
      sand.fill(-1);
      
      // Create explosion particles
      explosionParticles = [];
      console.log(`Found ${existingSand.length} sand particles to explode`);
      
      // Create explosions from each sand pile center
      pileCenters.forEach((center, centerIndex) => {
        // Find particles near this center
        const nearbyParticles = existingSand.filter(particle => {
          const distance = Math.sqrt(
            Math.pow(particle.x - center.x, 2) + 
            Math.pow(particle.y - center.y, 2)
          );
          return distance < 30; // Within 30 pixels of center
        });

        // Create explosion particles from nearby sand
        nearbyParticles.forEach((particle, index) => {
          // Create multiple explosion particles from each sand grain
          const explosionCount = 2 + Math.floor(Math.random() * 3); // 2-4 particles per grain
          
          for(let i = 0; i < explosionCount; i++){
            // Calculate explosion direction (outward from pile center)
            const dx = particle.x - center.x;
            const dy = particle.y - center.y;
            
            // If particle is at center, use random direction
            let angle;
            if(dx === 0 && dy === 0){
              angle = Math.random() * Math.PI * 2;
            } else {
              angle = Math.atan2(dy, dx) + (Math.random() - 0.5) * 1.0;
            }
            
            const speed = 1.5 + Math.random() * 3; // Explosion speed
            const explosionDistance = 40 + Math.random() * 120;
            
            const targetX = particle.x + Math.cos(angle) * explosionDistance;
            const targetY = particle.y + Math.sin(angle) * explosionDistance;
            
            // Use the original sand color with slight variation
            const colorVariation = Math.random() * 0.2 - 0.1; // ¬±10% variation
            const originalColor = particle.color;
            const r = (originalColor >> 16) & 255;
            const g = (originalColor >> 8) & 255;
            const b = originalColor & 255;
            
            const newR = Math.max(0, Math.min(255, Math.floor(r + colorVariation * 255)));
            const newG = Math.max(0, Math.min(255, Math.floor(g + colorVariation * 255)));
            const newB = Math.max(0, Math.min(255, Math.floor(b + colorVariation * 255)));
            
            const newColor = (255 << 24) | (newR << 16) | (newG << 8) | newB;
            
            explosionParticles.push({
              x: particle.x,
              y: particle.y,
              targetX: targetX,
              targetY: targetY,
              color: newColor,
              life: 120 + Math.random() * 80, // 120-200 frames (longer to settle)
              maxLife: 120 + Math.random() * 80,
              vx: Math.cos(angle) * speed,
              vy: Math.sin(angle) * speed,
              gravity: 0.12 + Math.random() * 0.08 // Slightly stronger gravity
            });
          }
        });
      });
      
      console.log(`Created ${explosionParticles.length} explosion particles`);

      // Start explosion animation
      explosionActive = true;
      if(!sandAnimating){
        sandAnimating = true;
        requestAnimationFrame(loopSand);
      }

      // Add screen shake effect
      document.body.style.animation = 'none';
      document.body.offsetHeight; // Trigger reflow
      document.body.style.animation = 'screenShake 0.5s ease-in-out';
      
      // Add explosion sound effect
      try {
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        const filter = ctx.createBiquadFilter();
        
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(60, ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(20, ctx.currentTime + 0.8);
        
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(200, ctx.currentTime);
        filter.frequency.exponentialRampToValueAtTime(50, ctx.currentTime + 0.8);
        
        gain.gain.setValueAtTime(0.3, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.8);
        
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(ctx.destination);
        osc.start();
        osc.stop(ctx.currentTime + 0.8);
      } catch(e) {
        // Audio context might not be available
      }
    }

    // ---------- Lightning ----------
    function lightningStrike(){
      const boltCount=Math.floor(Math.random()*3)+2;
      const flash=document.createElement('div'); flash.style.position='fixed'; flash.style.inset='0'; flash.style.background='black'; flash.style.opacity=0; flash.style.zIndex=9998; flash.style.pointerEvents='none'; document.body.appendChild(flash);
      flash.animate([{opacity:0},{opacity:.8,offset:.1},{opacity:.4,offset:.3},{opacity:0}],{duration:600,easing:'ease-out'});
      setTimeout(()=>flash.remove(),700);
      for(let i=0;i<boltCount;i++){
        const bolt=document.createElement('div'); bolt.style.position='fixed'; bolt.style.top='0'; bolt.style.left=Math.random()*80+10+'%'; bolt.style.width='4px'; bolt.style.height=window.innerHeight+'px'; bolt.style.background='repeating-linear-gradient(170deg, #ffffe0 0 5px, #fff 5px 10px, transparent 10px 12px)'; bolt.style.filter='drop-shadow(0 0 12px #fff59d)'; bolt.style.opacity=0; bolt.style.zIndex=9999; document.body.appendChild(bolt);
        bolt.animate([{opacity:0},{opacity:1,offset:.1},{opacity:.7,offset:.3},{opacity:0}],{duration:500+Math.random()*300,easing:'ease-out'});
        const splash=document.createElement('div'); splash.style.position='fixed'; splash.style.bottom='0'; splash.style.left=`calc(${bolt.style.left} + 2px)`; splash.style.width='10px'; splash.style.height='10px'; splash.style.borderRadius='50%'; splash.style.background='radial-gradient(circle, #ffeb3b, #ff9800, transparent)'; splash.style.filter='blur(1px)'; splash.style.opacity=0; splash.style.zIndex=9999; document.body.appendChild(splash);
        splash.animate([{transform:'translateY(0) scale(0.5)',opacity:1},{transform:'translateY(-20px) scale(1.5)',opacity:0}],{duration:500,easing:'ease-out',delay:200+Math.random()*200});
        setTimeout(()=>bolt.remove(),800); setTimeout(()=>splash.remove(),800);
      }
      const ctx=new (window.AudioContext||window.webkitAudioContext)(); const osc=ctx.createOscillator(); const gain=ctx.createGain(); osc.type='sawtooth'; osc.frequency.setValueAtTime(40, ctx.currentTime); gain.gain.setValueAtTime(0.2, ctx.currentTime); gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime+1.2); osc.connect(gain); gain.connect(ctx.destination); osc.start(); osc.stop(ctx.currentTime+1.2);
    }

    // ---------- Rocket Launch ----------
    function rocketLaunchExplosion(){
      const totalRockets = 2 + Math.floor(Math.random()*2);
      for(let i=0;i<totalRockets;i++){
        const rocket=document.createElement('div'); rocket.style.position='fixed'; rocket.style.bottom='-60px'; rocket.style.left=Math.random()*80+10+'%'; rocket.style.width='20px'; rocket.style.height='60px'; rocket.style.background='linear-gradient(to top, #b71c1c, #e53935)'; rocket.style.borderRadius='8px'; rocket.style.zIndex=9999; rocket.style.boxShadow='0 0 6px #ff6f00'; rocket.style.transform=`rotate(${(Math.random()-0.5)*40}deg)`; document.body.appendChild(rocket);
        const flame=document.createElement('div'); flame.style.position='absolute'; flame.style.bottom='-20px'; flame.style.left='50%'; flame.style.transform='translateX(-50%)'; flame.style.width='10px'; flame.style.height='20px'; flame.style.background='radial-gradient(circle at center, #ffb300, #ff6f00 70%, rgba(255,111,0,0))'; flame.style.borderRadius='50%'; rocket.appendChild(flame);
        const travelX=(Math.random()-0.5)*window.innerWidth*0.8; const travelY=-window.innerHeight*(0.7+Math.random()*0.4); const duration=1500+Math.random()*1000;
        rocket.animate([{transform: rocket.style.transform + ' translate(0,0)'},{transform: rocket.style.transform + ` translate(${travelX}px, ${travelY}px)`}], {duration, easing:'ease-out'});
        const ctx=new AudioContext(); const osc=ctx.createOscillator(); const gain=ctx.createGain(); osc.type='sawtooth'; osc.frequency.setValueAtTime(180+Math.random()*50, ctx.currentTime); gain.gain.setValueAtTime(0.15, ctx.currentTime); gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime+1.5); osc.connect(gain); gain.connect(ctx.destination); osc.start(); osc.stop(ctx.currentTime+1.5);
        setTimeout(()=>{ rocket.animate([{opacity:1},{opacity:0}],{duration:300}); setTimeout(()=>rocket.remove(),400); }, duration-300);
      }
    }

    // ---- Drawing overlay ----
    const drawCanvas = document.createElement('canvas');
    drawCanvas.id = 'drawCanvas';
    drawCanvas.style.position = 'fixed';
    drawCanvas.style.zIndex = '20';
    drawCanvas.style.pointerEvents = 'none'; // disabled on setup/done
    document.getElementById('drill').appendChild(drawCanvas);

    const dctx = drawCanvas.getContext('2d');
    let drawing = false;

    // üñäÔ∏è Resize and align canvas to cover the question only
    function positionDrawCanvasOverQuestion() {
      const drill = document.getElementById('drill');
      const q = document.querySelector('#question pre.vert');
      const ans = document.getElementById('answer');
      if (!q || !ans) return;

      const qRect = q.getBoundingClientRect();
      const aRect = ans.getBoundingClientRect();
      const drillRect = drill.getBoundingClientRect();

      // Cover from just above the question to just below the answer
      const top = Math.floor(qRect.top - drillRect.top - 20);
      const bottom = Math.ceil(aRect.bottom - drillRect.top + 20);
      const height = bottom - top;

      drawCanvas.width = Math.ceil(drillRect.width);
      drawCanvas.height = Math.ceil(height);

      drawCanvas.style.position = 'absolute';
      drawCanvas.style.left = '0px';
      drawCanvas.style.top = `${top}px`;
      drawCanvas.style.zIndex = 20;
      drawCanvas.style.pointerEvents = 'auto';
    }



    // ‚úèÔ∏è Drawing events
    drawCanvas.addEventListener('mousedown', e => {
      drawing = true;
      const x = e.clientX - drawCanvas.getBoundingClientRect().left;
      const y = e.clientY - drawCanvas.getBoundingClientRect().top;
      dctx.beginPath();
      dctx.moveTo(x, y);
    });
    drawCanvas.addEventListener('mousemove', e => {
      if (!drawing) return;
      const x = e.clientX - drawCanvas.getBoundingClientRect().left;
      const y = e.clientY - drawCanvas.getBoundingClientRect().top;
      dctx.lineTo(x, y);
      dctx.strokeStyle = '#007BFF';
      dctx.lineWidth = 2;
      dctx.lineCap = 'round';
      dctx.stroke();
    });
    drawCanvas.addEventListener('mouseup', () => (drawing = false));
    drawCanvas.addEventListener('mouseleave', () => (drawing = false));

    // ‚úã Touch support
    drawCanvas.addEventListener('touchstart', e => {
      const t = e.touches[0];
      const rect = drawCanvas.getBoundingClientRect();
      drawing = true;
      dctx.beginPath();
      dctx.moveTo(t.clientX - rect.left, t.clientY - rect.top);
    });
    drawCanvas.addEventListener('touchmove', e => {
      if (!drawing) return;
      const t = e.touches[0];
      const rect = drawCanvas.getBoundingClientRect();
      dctx.lineTo(t.clientX - rect.left, t.clientY - rect.top);
      dctx.strokeStyle = '#007BFF';
      dctx.lineWidth = 2;
      dctx.lineCap = 'round';
      dctx.stroke();
      e.preventDefault();
    });
    drawCanvas.addEventListener('touchend', () => (drawing = false));

    function clearDrawCanvas() {
      dctx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
    }

    // ‚úÖ Single resize listener
    window.addEventListener('resize', () => {
      if (document.getElementById('drill').style.display === 'block') {
        positionDrawCanvasOverQuestion();
      }
    });

    // ‚úÖ Show/hide the wipe button
    function showWipeButton(show) {
      const btn = document.getElementById('wipeBtn');
      if (!btn) return;
      btn.style.display = show ? 'block' : 'none';
    }

    // ‚úÖ Wipe button clears the notes canvas
    document.getElementById('wipeBtn').addEventListener('click', () => {
      clearDrawCanvas();
    });



  </script>
</body>
</html>
